/*
Arroyo - software for the simulation of electromagnetic wave propagation
through turbulence and optics.

Copyright (c) 2000-2004 California Institute of Technology.  Written by
Dr. Matthew Britton.  For comments or questions about this software,
please contact the author at mbritton@astro.caltech.edu.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as  published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

This program is provided "as is" and distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  In no
event shall California Institute of Technology be liable to any party
for direct, indirect, special, incidental or consequential damages,
including lost profits, arising out of the use of this software and its
documentation, even if the California Institute of Technology has been
advised of the possibility of such damage.   The California Institute of
Technology has no obligation to provide maintenance, support, updates,
enhancements or modifications.  See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
*/

#ifndef PALAO_RECONSTRUCTOR_H
#define PALAO_RECONSTRUCTOR_H

#include "zernike_projected_zonal_reconstructor.h"
#include "arroyo_least_squares_reconstructor.h"

namespace Arroyo {

  ///
  /// A class to hold the PALAO SCAO reconstructor.  
  ///
  /// There are a couple special features of this class.  First,
  /// there's a built in mapping of the actuator numbering scheme used
  /// in the reconstructor.  This information is contained in the dm
  /// actuator lookup table.  Second, there is an explicit subaperture
  /// weighting scheme encoded in the centroid weighting lookup table.
  /// This compensates for the fact that the reconstructors used by
  /// PALAO do not necessarily give zero weight to unilluminated
  /// subapertures.  For the reconstructors generated by A++ and
  /// converted to this format, the elements of the reconstructor used
  /// to compute tip and tilt are nonzero even for unilluminated
  /// subaps.  For Doug MacMartin's reconstructors, all elements of
  /// the reconstructor have nonzero values - the ones corresponding
  /// to unilluminated subaps have values corresponding to numerical
  /// roundoff errors of order 1e-15.  The centroid weighting lookup
  /// table specifically zeroes contributions from unilluminated subaps.
  ///

  class PALAO_reconstructor :
    public zernike_projected_zonal_reconstructor,
    public Arroyo::pixel_array<double> {

    private:

    static const bool factory_registration;

    ////////////////////////////
    ///  Return a name unique to the class
    std::string unique_name() const {return(std::string("PALAO reconstructor"));};

    ////////////////////////////
    ///  Create the DM actuator lookup table
    void create_dm_actuator_lookup_table() const;

    ////////////////////////////
    ///  Create the centroid weighting lookup table
    void create_centroid_weighting_lookup_table() const;

    protected:

    ///////////////////////////////////////////
    ///  Null constructor
    PALAO_reconstructor(){
      create_dm_actuator_lookup_table();
    };

    // a vector whose index corresponds to the index on the 1D array
    // generated by the reconstructor, and whose values correspond to
    // the dm actuator location index in a 17x17 square grid
    mutable std::vector<long> dm_actuator_lookup_table;

    // a vector whose index corresponds to the array of Shack Hartmann
    // centroids, and whose values correspond to the weight given to
    // the centroid in the tip tilt measurement.
    mutable std::vector<double> centroid_weighting_lookup_table;

    public:

    ///////////////////////////////////////////
    ///  Copy constructor
    PALAO_reconstructor(const PALAO_reconstructor & palao_recon);

    ///////////////////////////////////////////
    ///  Construct from an arroyo least squares reconstructor
    template<typename T>
    PALAO_reconstructor(const arroyo_least_squares_reconstructor<T> & arroyo_recon);

    ///////////////////////////////////////////
    ///  Construct from file
    PALAO_reconstructor(const char * filename);

    ///////////////////////////////////////////
    ///  Construct from iofits object
    PALAO_reconstructor(const Arroyo::iofits & iof);

    ///////////////////////////////////////////
    ///  Destructor
    ~PALAO_reconstructor(){};

    ///////////////////////////////////////////
    ///  Operator = 
    PALAO_reconstructor & operator=(const PALAO_reconstructor & palao_recon);

     ///////////////////////////////////////////
    ///  Read from file
    void read(const char * filename);

    ///////////////////////////////////////////
    ///  Read from iofits
    void read(const Arroyo::iofits & iof);

    ///////////////////////////////////////////
    ///  Write to file
    void write(const char * filename) const;
 
    ///////////////////////////////////////////
    ///  Write to iofits
    void write(Arroyo::iofits & iof) const;
 
    ///////////////////////////////////////////
    ///  Print
    void print(std::ostream & os, const char * prefix="") const;

    ///////////////////////////////////////////
    ///  Get dimensions of centroid measurements passed
    ///  to the reconstructor
    vector<long> get_centroid_axes() const;

    ///////////////////////////////////////////
    ///  Get dimensions of pixel array returned
    ///  by the reconstructor
    vector<long> get_actuator_axes() const;

    ///////////////////////////////////////////
    ///  Get a zernike instance that contains information
    ///  about which modes are returned by the reconstructor.
    /// 
    ///  This instance is minimally sized so as to hold the largest
    ///  mode returned by the reconstructor.  Each element of this
    ///  instance is initialized to unity if the corresponding mode is
    ///  returned by the reconstructor, and to zero if it is not
    Arroyo::zernike get_zernike_modes() const;

    ///////////////////////////////////////////
    ///  Reconstruct the zernike residuals from 
    ///  Shack Hartmann centroid data
    ///
    /// This reconstructor reconstructs a zernike instance
    /// with tip and tilt modes
    void reconstruct_zernike_residuals(const Arroyo::Shack_Hartmann_centroids & shcentroids, 
				       Arroyo::zernike & znke) const;

    ///////////////////////////////////////////
    ///  Reconstruct the zonal residuals from a
    ///  Shack Hartmann centroid class instance
    void reconstruct_zonal_residuals(const Arroyo::Shack_Hartmann_centroids & shcentroids, 
				     Arroyo::pixel_array<double> & pixarr) const;

    ///////////////////////////////////////////
    ///  Reconstruct the residuals from 
    ///  Shack Hartmann centroid data
    ///
    /// This reconstructor reconstructs a zernike instance
    /// with tip and tilt modes, and a pixel array containing
    /// zonal residuals
    void reconstruct_residuals(const Arroyo::Shack_Hartmann_centroids & shcentroids, 
			       Arroyo::zernike & znke, 
			       Arroyo::pixel_array<double> & pixarr) const;
  };

  template<typename T>
  PALAO_reconstructor::PALAO_reconstructor(const arroyo_least_squares_reconstructor<T> & arroyo_recon){

    vector<long> arroyo_axes = arroyo_recon.get_axes();

    if(arroyo_axes[0]!=512 || 
       arroyo_axes[1]!=292){
      cerr << "PALAO_reconstructor::PALAO_reconstructor error - mismatched axes\n";
      cerr << arroyo_axes[0] 
	   << ", "
	   << arroyo_axes[1]
	   << endl;
      throw(string("PALAO_reconstructor::PALAO_reconstructor"));
    }

    vector<long> palao_axes(2,512);
    palao_axes[1] = 256;
    this->pixel_array<double>::set_axes(palao_axes);
    
    bool entire_row_zero;
    int row_count=-1;
    int npalao_rows = 243;
    // These conversion facs scale the arroyo recon matrix elements
    // to the values used at Palomar.  Actuator commands are the
    // product of the matrix elements times the gain, so overall
    // normalizations end up absorbed into the control loop gains.
    double ho_conversion_fac = .70201;
    double tt_conversion_fac = .5403125;
    for(int j=0; j<npalao_rows; j++){
      
      entire_row_zero = true;
      while(entire_row_zero){
	row_count++;
	for(int i=0; i<arroyo_axes[0]; i++){
	  if(fabs(arroyo_recon.data(arroyo_axes[0]*row_count+i))>1e-6){
	    entire_row_zero = false;
	    break;
	  }
	}
      }
	
      if(entire_row_zero==false){
	for(int i=0; i<arroyo_axes[0]/2; i++){

	  if(j<npalao_rows-2){
	    this->pixeldata[j*palao_axes[0]+2*i] = 
	      -ho_conversion_fac*arroyo_recon.data(arroyo_axes[0]*row_count+i+arroyo_axes[0]/2);
	    this->pixeldata[j*palao_axes[0]+2*i+1] = 
	      ho_conversion_fac*arroyo_recon.data(arroyo_axes[0]*row_count+i);
	  } else {
	    this->pixeldata[j*palao_axes[0]+2*i] = 
	      tt_conversion_fac*arroyo_recon.data(arroyo_axes[0]*row_count+i);
	    this->pixeldata[j*palao_axes[0]+2*i+1] = 
	      -tt_conversion_fac*arroyo_recon.data(arroyo_axes[0]*row_count+i+arroyo_axes[0]/2);
	  }

	}
      }
    }
  }

}

#endif
